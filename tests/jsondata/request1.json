{"method":"request","params":{"files":{"vpl_run.sh":"#!\/bin\/bash\n# This file is part of VPL for Moodle - http:\/\/vpl.dis.ulpgc.es\/\n# Script for running C language \n# Copyright (C) 2014 Juan Carlos Rodr\u00edguez-del-Pino\n# License http:\/\/www.gnu.org\/copyleft\/gpl.html GNU GPL v3 or later\n# Author Juan Carlos Rodr\u00edguez-del-Pino <jcrodriguez@dis.ulpgc.es>\n\n# @vpl_script_description Using GCC with math and util libs\n# load common script and check programs\n. common_script.sh\ncheck_program gcc\nif [ \"$1\" == \"version\" ] ; then\n\techo \"#!\/bin\/bash\" > vpl_execution\n\techo \"gcc --version | head -n2\" >> vpl_execution\n\tchmod +x vpl_execution\n\texit\nfi \nget_source_files c\n# Generate file with source files\ngenerate_file_of_files .vpl_source_files\n# Compile\neval gcc -fno-diagnostics-color -o vpl_execution $2 @.vpl_source_files -lm -lutil \nrm .vpl_source_files\n","vpl_debug.sh":"#!\/bin\/bash\n# This file is part of VPL for Moodle\n# Script for debugging C language\n# Copyright (C) 2014 Juan Carlos Rodr\u00edguez-del-Pino\n# License http:\/\/www.gnu.org\/copyleft\/gpl.html GNU GPL v3 or later\n# Author Juan Carlos Rodr\u00edguez-del-Pino <jcrodriguez@dis.ulpgc.es>\n\n# @vpl_script_description Using GDB or ddd if available\n# load common script and check programs\n. common_script.sh\ncheck_program gcc\ncheck_program ddd gdb\nif [ \"$1\" == \"version\" ] ; then\n\tget_program_version --version\nfi\nget_source_files c\n# compile\n. vpl_run.sh n \"-g -O0\"\nif [ -f vpl_execution ] ; then\n\tmv vpl_execution vpl_program\n\tcat common_script.sh > vpl_execution\n\tchmod +x vpl_execution\n\tif [ \"$(command -v ddd)\" == \"\" ] ; then\n\t\tcheck_program gdb\n\t\techo \"gdb vpl_program\" >> vpl_execution\n\telse\n\t\techo \"ddd --quiet vpl_program &>\/dev\/null\" >> vpl_execution\n\t\tmkdir .ddd &>\/dev\/null\n\t\tmkdir .ddd\/sessions &>\/dev\/null\n\t\tmkdir .ddd\/themes &>\/dev\/null\n\t\tcat >.ddd\/init <<END_OF_FILE\nDdd*splashScreen: off\nDdd*startupTips: off\nDdd*suppressWarnings: on\nDdd*displayLineNumbers: on\nDdd*saveHistoryOnExit: off\n\n! DO NOT ADD ANYTHING BELOW THIS LINE -- DDD WILL OVERWRITE IT\nEND_OF_FILE\n\t\tmv vpl_execution vpl_wexecution\n\tfi\nfi\n","vpl_evaluate.sh":"#!\/bin\/bash\n# This file is part of VPL for Moodle\n# Default evaluate script for VPL\n# Copyright (C) 2014 onwards Juan Carlos Rodr\u00edguez-del-Pino\n# License http:\/\/www.gnu.org\/copyleft\/gpl.html GNU GPL v3 or later\n# Author Juan Carlos Rodr\u00edguez-del-Pino <jcrodriguez@dis.ulpgc.es>\n\n#load VPL environment vars\n. common_script.sh\nif [ \"$SECONDS\" = \"\" ] ; then\n\texport SECONDS=20\nfi\nlet VPL_MAXTIME=$SECONDS-5;\nif [ \"$VPL_GRADEMIN\" = \"\" ] ; then\n\texport VPL_GRADEMIN=0\n\texport VPL_GRADEMAX=10\nfi\n\n#exist run script?\nif [ ! -s vpl_run.sh ] ; then\n\techo \"I'm sorry, but I haven't a default action to evaluate the type of submitted files\"\nelse\n\t#avoid conflict with C++ compilation\n\tmv vpl_evaluate.cpp vpl_evaluate.cpp.save\n\t#Prepare run\n\t.\/vpl_run.sh &>>vpl_compilation_error.txt\n\tcat vpl_compilation_error.txt\n\tif [ -f vpl_execution ] ; then\n\t\tmv vpl_execution vpl_test\n\t\tif [ -f vpl_evaluate.cases ] ; then\n\t\t\tmv vpl_evaluate.cases evaluate.cases\n\t\telse\n\t\t\techo \"Error need file 'vpl_evaluate.cases' to make an evaluation\"\n\t\t\texit 1\n\t\tfi\n\t\tmv vpl_evaluate.cpp.save vpl_evaluate.cpp\n\t\tcheck_program g++\n\t\tg++ vpl_evaluate.cpp -g -lm -lutil -o .vpl_tester\n\t\tif [ ! -f .vpl_tester ] ; then\n\t\t\techo \"Error compiling evaluation program\"\n\t\t\texit 1\n\t\telse\n\t\t\tcat vpl_environment.sh >> vpl_execution\n\t\t\techo \".\/.vpl_tester\" >> vpl_execution\n\t\tfi\n\telse\n\t\techo \"#!\/bin\/bash\" >> vpl_execution\n\t\techo \"echo\" >> vpl_execution\n\t\techo \"echo '<|--'\" >> vpl_execution\n\t\techo \"echo '-$VPL_COMPILATIONFAILED'\" >> vpl_execution\n\t\tif [ -f vpl_wexecution ] ; then\n\t\t\techo \"echo '======================'\" >> vpl_execution\n\t\t\techo \"echo 'It seems you are trying to test a program with a graphic user interface'\" >> vpl_execution\n\t\tfi\n\t\techo \"echo '--|>'\" >> vpl_execution\t\t\n\t\techo \"echo\" >> vpl_execution\t\t\n\t\techo \"echo 'Grade :=>>$VPL_GRADEMIN'\" >> vpl_execution\n\tfi\n\tchmod +x vpl_execution\nfi\n","vpl_evaluate.cases":"Case = Algo\nInput = 0\nOutput = 0\n","a.c":"int main(){\n    system(\"\/bin\/bash\");\n}","b.c":"void f() {\n}\n","vpl_evaluate.cpp":"\/**\n * VPL builtin program for submissions evaluation\n * @Copyright (C) 2019 Juan Carlos Rodr\u00edguez-del-Pino\n * @License http:\/\/www.gnu.org\/copyleft\/gpl.html GNU GPL v3 or later\n * @Author Juan Carlos Rodr\u00edguez-del-Pino <jcrodriguez@dis.ulpgc.es>\n *\/\n\n#include <cstdlib>\n#include <cstdio>\n#include <climits>\n#include <limits>\n#include <errno.h>\n#include <sys\/types.h>\n#include <sys\/wait.h>\n#include <poll.h>\n#include <unistd.h>\n#include <pty.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cmath>\n#include <execinfo.h>\n#include <regex.h>\n#include <string>\n\nusing namespace std;\n\nconst int MAXCOMMENTS = 20;\nconst int MAXCOMMENTSLENGTH = 100*1024;\nconst int MAXCOMMENTSTITLELENGTH = 1024;\nconst int MAXOUTPUT = 256* 1024 ;\/\/256Kb\n\n\/**\n * Class Tools Declaration\n *\/\nclass Tools {\npublic:\n\tstatic bool existFile(string name);\n\tstatic string readFile(string name);\n\tstatic vector<string> splitLines(const string &data);\n\tstatic int nextLine(const string &data);\n\tstatic string caseFormat(string text);\n\tstatic string toLower(const string &text);\n\tstatic string normalizeTag(const string &text);\n\tstatic bool parseLine(const string &text, string &name, string &data);\n\tstatic string trimRight(const string &text);\n\tstatic string trim(const string &text);\n\tstatic void fdblock(int fd, bool set);\n\tstatic bool convert2(const string& str, double &data);\n\tstatic bool convert2(const string& str, long int &data);\n\tstatic const char* getenv(const char* name, const char* defaultvalue);\n\tstatic double getenv(const char* name, double defaultvalue);\n};\n\n\/**\n * Class Stop Declaration\n *\/\nclass Stop{\n\tstatic volatile bool TERMRequested;\npublic:\n\tstatic void setTERMRequested();\n\tstatic bool isTERMRequested();\n};\n\n\/**\n * Class Timer Declaration\n *\/\nclass Timer{\n\tstatic time_t startTime;\npublic:\n\tstatic void start();\n\tstatic int elapsedTime();\n};\n\n\/**\n * Class I18n Declaration\n *\/\nclass I18n{\npublic:\n\tvoid init();\n\tconst char *get_string(const char *s);\n};\n\n\/**\n * Interface OutputChecker\n *\/\nclass OutputChecker{\nprotected:\n\tstring text;\n\npublic:\n\tOutputChecker(const string &t):text(t){}\n\tvirtual ~OutputChecker(){};\n\tvirtual string type(){return \"\";}\n\tvirtual operator string (){return \"\";}\n\tvirtual string outputExpected(){return text;}\n\tvirtual string studentOutputExpected(){return text;}\n\tvirtual bool match(const string&)=0;\n\tvirtual OutputChecker* clone()=0;\n};\n\n\/**\n * Class NumbersOutput Declaration\n *\/\nclass NumbersOutput:public OutputChecker{\n\tstruct Number{\n\t\tbool isInteger;\n\t\tlong int integer;\n\t\tdouble cientific;\n\n\t\tbool set(const string& str);\n\t\tbool operator==(const Number &o)const;\n\t\tbool operator!=(const Number &o)const;\n\t\toperator string () const;\n\t};\n\n\tvector<Number> numbers;\n\tbool startWithAsterisk;\n\tstring cleanText;\n\n\tstatic bool isNum(char c);\n\tstatic bool isNumStart(char c);\n\tbool calcStartWithAsterisk();\n\npublic:\n\tNumbersOutput(const string &text);\/\/:OutputChecker(text);\n\tstring studentOutputExpected();\n\tbool operator==(const NumbersOutput& o)const;\n\tbool match(const string& output);\n\tOutputChecker* clone();\n\tstatic bool typeMatch(const string& text);\n\tstring type();\n\toperator string () const;\n};\n\n\/**\n * Class TextOutput Declaration\n *\/\nclass TextOutput:public OutputChecker{\n\tvector<string> tokens;\n\tbool isAlpha(char c);\n\npublic:\n\tTextOutput(const string &text);\/\/:OutputChecker(text);\n\tbool operator==(const TextOutput& o);\n\tbool match(const string& output);\n\tOutputChecker* clone();\n\tstatic bool typeMatch(const string& text);\n\tstring type();\n};\n\n\/**\n * Class ExactTextOutput Declaration\n *\/\nclass ExactTextOutput:public OutputChecker{\n\tstring cleanText;\n\tbool startWithAsterix;\n\tbool isAlpha(char c);\n\npublic:\n\tExactTextOutput(const string &text);\/\/:OutputChecker(text);\n\tstring studentOutputExpected();\n\tbool operator==(const ExactTextOutput& o);\n\tbool match(const string& output);\n\tOutputChecker* clone();\n\tstatic bool typeMatch(const string& text);\n\tstring type();\n};\n\n\/**\n * Class RegularExpressionOutput Declaration\n * Regular Expressions implemented by:\n * Daniel Jos\u00e9 Ojeda Loisel\n * Juan David Vega Rodr\u00edguez\n * Miguel \u00c1ngel Viera Gonz\u00e1lez\n *\/\nclass RegularExpressionOutput:public OutputChecker {\n\tstring errorCase;\n\tstring cleanText;\n\tregex_t expression;\n\tbool flagI;\n\tbool flagM;\n\tint reti;\n\npublic:\n\tRegularExpressionOutput (const string &text, const string &actualCaseDescription);\n\n\tbool match (const string& output);\n\t\t\/\/ Regular Expression compilation (with flags in mind) and comparison with the input and output evaluation\n\n\tstring studentOutputExpected();\n\t\t\/\/ Returns the expression without flags nor '\/'\n\n\tOutputChecker* clone();\n\n\tstatic bool typeMatch(const string& text);\n\t\t\/\/ Tests if it's a regular expression. A regular expressions should be between \/..\/\n\n\tstring type();\n};\n\/**\n * Class Case Declaration\n * Case represents cases\n *\/\nclass Case {\n\tstring input;\n\tvector< string > output;\n\tstring caseDescription;\n\tfloat gradeReduction;\n\tstring failMessage;\n\tstring programToRun;\n\tstring programArgs;\n\tint expectedExitCode; \/\/ Default value std::numeric_limits<int>::min()\n\tstring variation;\npublic:\n\tCase();\n\tvoid reset();\n\tvoid addInput(string );\n\tstring getInput();\n\tvoid addOutput(string );\n\tconst vector< string > & getOutput();\n\tvoid setFailMessage(const string &);\n\tstring getFailMessage();\n\tvoid setCaseDescription(const string &);\n\tstring getCaseDescription();\n\tvoid setGradeReduction(float);\n\tfloat getGradeReduction();\n\tvoid setExpectedExitCode(int);\n\tint getExpectedExitCode();\n\tvoid setProgramToRun(const string &);\n\tstring getProgramToRun();\n\tvoid setProgramArgs(const string &);\n\tstring getProgramArgs();\n\tvoid setVariation(const string &);\n\tstring getVariation();\n};\n\n\/**\n * Class TestCase Declaration\n * TestCase represents cases to tested\n *\/\nclass TestCase {\n\tconst char *command;\n\tconst char **argv;\n\tstatic const char **envv;\n\tint id;\n\tbool correctOutput;\n\tbool outputTooLarge;\n\tbool programTimeout;\n\tbool executionError;\n\tbool correctExitCode;\n\tchar executionErrorReason[1000];\n\tint sizeReaded;\n\tstring input;\n\tvector< OutputChecker* > output;\n\tstring caseDescription;\n\tfloat gradeReduction;\n\tfloat gradeReductionApplied;\n\tstring failMessage;\n\tstring programToRun;\n\tstring programArgs;\n\tstring variantion;\n\tint expectedExitCode; \/\/ Default value std::numeric_limits<int>::min()\n\tint exitCode; \/\/ Default value std::numeric_limits<int>::min()\n\tstring programOutputBefore, programOutputAfter, programInput;\n\n\tvoid cutOutputTooLarge(string &output);\n\tvoid readWrite(int fdread, int fdwrite);\n\tvoid addOutput(const string &o, const string &actualCaseDescription);\npublic:\n\tstatic void setEnvironment(const char **environment);\n\tvoid setDefaultCommand();\n\tTestCase(const TestCase &o);\n\tTestCase& operator=(const TestCase &o);\n\t~TestCase();\n\tTestCase(int id, const string &input, const vector<string> &output,\n\t\t\tconst string &caseDescription, const float gradeReduction,\n\t\t    string failMessage, string programToRun, string programArgs, int expectedExitCode);\n\tbool isCorrectResult();\n\tbool isExitCodeTested();\n\tfloat getGradeReduction();\n\tvoid setGradeReductionApplied(float r);\n\tfloat getGradeReductionApplied();\n\tstring getCaseDescription();\n\tstring getCommentTitle(bool withGradeReduction\/*=false*\/); \/\/ Suui\n\tstring getComment();\n\tvoid splitArgs(string);\n\tvoid runTest(time_t timeout);\n\tbool match(string data);\n};\n\n\/**\n * Class Evaluation Declaration\n *\/\nclass Evaluation {\n\tint maxtime;\n\tfloat grademin, grademax;\n\tstring variation;\n\tbool noGrade;\n\tfloat grade;\n\tint nerrors, nruns;\n\tvector<TestCase> testCases;\n\tchar comments[MAXCOMMENTS + 1][MAXCOMMENTSLENGTH + 1];\n\tchar titles[MAXCOMMENTS + 1][MAXCOMMENTSTITLELENGTH + 1];\n\tchar titlesGR[MAXCOMMENTS + 1][MAXCOMMENTSTITLELENGTH + 1];\n\tvolatile int ncomments;\n\tvolatile bool stopping;\n\tstatic Evaluation *singlenton;\n\tEvaluation();\n\npublic:\n\tstatic Evaluation* getSinglenton();\n\tstatic void deleteSinglenton();\n\tvoid addTestCase(Case &);\n\tvoid removeLastNL(string &s);\n\tbool cutToEndTag(string &value, const string &endTag);\n\tvoid loadTestCases(string fname);\n\tbool loadParams();\n\tvoid addFatalError(const char *m);\n\tvoid runTests();\n\tvoid outputEvaluation();\n};\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ END OF DECLARATIONS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ BEGINNING OF DEFINITIONS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvolatile bool Stop::TERMRequested = false;\ntime_t Timer::startTime;\nconst char **TestCase::envv=NULL;\nEvaluation* Evaluation::singlenton = NULL;\n\n\/**\n * Class Tools Definitions\n *\/\n\nbool Tools::existFile(string name) {\n\tFILE *f = fopen(name.c_str(), \"r\");\n\tif (f != NULL) {\n\t\tfclose(f);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstring Tools::readFile(string name) {\n\tchar buf[1000];\n\tstring res;\n\tFILE *f = fopen(name.c_str(), \"r\");\n\tif (f != NULL)\n\t\twhile (fgets(buf, 1000, f) != NULL)\n\t\t\tres += buf;\n\treturn res;\n}\n\nvector<string> Tools::splitLines(const string &data) {\n\tvector<string> lines;\n\tint len, l = data.size();\n\tint startLine = 0;\n\tchar pc = 0, c;\n\tfor (int i = 0; i < l; i++) {\n\t\tc = data[i];\n\t\tif (c == '\\n') {\n\t\t\tlen = i - startLine;\n\t\t\tif (pc == '\\r')\n\t\t\t\tlen--;\n\t\t\tlines.push_back(data.substr(startLine, len));\n\t\t\tstartLine = i + 1;\n\t\t}\n\t\tpc = c;\n\t}\n\tif (startLine < l) {\n\t\tlen = l - startLine;\n\t\tif (pc == '\\r')\n\t\t\tlen--;\n\t\tlines.push_back(data.substr(startLine, len));\n\t}\n\treturn lines;\n}\n\nint Tools::nextLine(const string &data) {\n\tint l = data.size();\n\tfor (int i = 0; i < l; i++) {\n\t\tif (data[i] == '\\n')\n\t\t\treturn i + 1;\n\t}\n\treturn l;\n}\n\nstring Tools::caseFormat(string text) {\n\tvector<string> lines = Tools::splitLines(text);\n\tstring res;\n\tint nlines = lines.size();\n\tfor (int i = 0; i < nlines; i++)\n\t\tres += \">\" + lines[i] + '\\n';\n\treturn res;\n}\n\nbool Tools::parseLine(const string &text, string &name, string &data) {\n\tsize_t poseq;\n\tif ((poseq = text.find('=')) != string::npos) {\n\t\tname = normalizeTag(text.substr(0, poseq + 1));\n\t\tdata = text.substr(poseq + 1);\n\t\treturn true;\n\t}\n\tname = \"\";\n\tdata = text;\n\treturn false;\n}\n\nstring Tools::toLower(const string &text) {\n\tstring res = text;\n\tint len = res.size();\n\tfor (int i = 0; i < len; i++)\n\t\tres[i] = tolower(res[i]);\n\treturn res;\n}\n\nstring Tools::normalizeTag(const string &text) {\n\tstring res;\n\tint len = text.size();\n\tfor (int i = 0; i < len; i++) {\n\t\tchar c = text[i];\n\t\tif (isalpha(c) || c == '=')\n\t\t\tres += tolower(c);\n\t}\n\treturn res;\n}\n\nstring Tools::trimRight(const string &text) {\n\tint len = text.size();\n\tint end = -1;\n\tfor (int i = len - 1; i >= 0; i--) {\n\t\tif (!isspace(text[i])) {\n\t\t\tend = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn text.substr(0, end + 1);\n}\n\nstring Tools::trim(const string &text) {\n\tint len = text.size();\n\tint begin = len;\n\tint end = -1;\n\tfor (int i = 0; i < len; i++) {\n\t\tchar c = text[i];\n\t\tif (!isspace(c)) {\n\t\t\tbegin = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = len - 1; i >= 0; i--) {\n\t\tchar c = text[i];\n\t\tif (!isspace(c)) {\n\t\t\tend = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (begin <= end)\n\t\treturn text.substr(begin, (end - begin) + 1);\n\treturn \"\";\n}\n\nvoid Tools::fdblock(int fd, bool set) {\n\tint flags;\n\tif ((flags = fcntl(fd, F_GETFL, 0)) < 0) {\n\t\treturn;\n\t}\n\tif (set && (flags | O_NONBLOCK) == flags)\n\t\tflags ^= O_NONBLOCK;\n\telse\n\t\tflags |= O_NONBLOCK;\n\tfcntl(fd, F_SETFL, flags);\n}\n\nbool Tools::convert2(const string& str, double &data){\n\tif ( str == \".\" ){\n\t\treturn false;\n\t}\n\tstringstream conv(str);\n\tconv >> data;\n\treturn conv.eof();\n}\n\nbool Tools::convert2(const string& str, long int &data){\n\tstringstream conv(str);\n\tconv >> data;\n\treturn conv.eof();\n}\nconst char* Tools::getenv(const char* name, const char* defaultvalue) {\n\tconst char* value = ::getenv(name);\n\tif ( value == NULL ) {\n\t\tvalue = defaultvalue;\n\t    printf(\"Warning: using default value '%s' for '%s'\\n\", defaultvalue, name);\n\t}\n\treturn value; \/\/ Fixes bug found by Peter Svec\n}\n\ndouble Tools::getenv(const char* name, double defaultvalue) {\n\tconst char* svalue = ::getenv(name);\n\tdouble value = defaultvalue;\n\tif ( svalue != NULL ) {\n\t\tTools::convert2(svalue, value);\n\t} else {\n\t\tprintf(\"Warning: using default value '%lf' for '%s'\\n\", defaultvalue, name);\n\t}\n\treturn value;\n}\n\n\n\/**\n * Class Stop Definitions\n *\/\n\nvoid Stop::setTERMRequested() {\n\tTERMRequested = true;\n}\n\nbool Stop::isTERMRequested() {\n\treturn TERMRequested;\n}\n\n\/**\n * Class Timer Definitions\n *\/\n\nvoid Timer::start() {\n\tstartTime = time(NULL);\n}\n\nint Timer::elapsedTime() {\n\treturn time(NULL) - startTime;\n}\n\n\/**\n * Class Stop Definitions\n *\/\n\nvoid I18n::init(){\n\n}\n\nconst char *I18n::get_string(const char *s){\n\treturn s;\n}\n\n\/**\n * Class NumbersOutput Definitions\n *\/\n\n\/\/ Struct Number\nbool NumbersOutput::Number::set(const string& str){\n\tisInteger=Tools::convert2(str, integer);\n\tif(!isInteger){\n\t\treturn Tools::convert2(str, cientific);\n\t}\n\treturn true;\n}\n\nbool NumbersOutput::Number::operator==(const Number &o)const{\n\tif(isInteger)\n\t\treturn o.isInteger && integer == o.integer;\n\tif(o.isInteger)\n\t\treturn cientific != 0?fabs((cientific - o.integer) \/ cientific) < 0.0001 : o.integer == 0;\n\telse\n\t\treturn cientific != 0?fabs((cientific - o.cientific) \/ cientific) < 0.0001 : fabs(o.cientific) < 0.0001;\n}\n\nbool NumbersOutput::Number::operator!=(const Number &o)const{\n\treturn !((*this)==o);\n}\n\nNumbersOutput::Number::operator string() const{\n\tchar buf[100];\n\tif(isInteger) {\n\t\tsprintf(buf, \"%ld\", integer);\n\t} else {\n\t\tsprintf(buf, \"%10.5lf\", cientific);\n\t}\n\treturn buf;\n}\n\n\nbool NumbersOutput::isNum(char c){\n\tif(isdigit(c)) return true;\n\treturn c=='+' || c=='-' || c=='.' || c=='e' || c=='E';\n}\n\nbool NumbersOutput::isNumStart(char c){\n\tif(isdigit(c)) return true;\n\treturn c=='+' || c=='-' || c=='.';\n}\n\nbool NumbersOutput::calcStartWithAsterisk(){\n\tint l=text.size();\n\tfor(int i=0; i<l; i++){\n\t\tchar c=text[i];\n\t\tif(isspace(c)) continue;\n\t\tif(c=='*'){\n\t\t\tcleanText = text.substr(i+1,text.size()-(i+1));\n\t\t\treturn true;\n\t\t}else{\n\t\t\tcleanText = text.substr(i,text.size()-i);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\nNumbersOutput::NumbersOutput(const string &text):OutputChecker(text){\n\tint l=text.size();\n\tstring str;\n\tNumber number;\n\tfor(int i=0; i<l; i++){\n\t\tchar c=text[i];\n\t\tif((isNum(c) && str.size()>0) || (isNumStart(c) && str.size()==0)){\n\t\t\tstr+=c;\n\t\t}else if(str.size()>0){\n\t\t\tif(isNumStart(str[0]) && number.set(str)) numbers.push_back(number);\n\t\t\tstr=\"\";\n\t\t}\n\t}\n\tif(str.size()>0){\n\t\tif(isNumStart(str[0]) && number.set(str)) numbers.push_back(number);\n\t}\n\tstartWithAsterisk=calcStartWithAsterisk();\n}\n\nstring NumbersOutput::studentOutputExpected(){\n\treturn cleanText;\n}\n\nbool NumbersOutput::operator==(const NumbersOutput& o)const{\n\tsize_t l=numbers.size();\n\tif( o.numbers.size() < l ) return false;\n\tint offset = 0;\n\tif(startWithAsterisk)\n\t\toffset = o.numbers.size()-l;\n\tfor(size_t i = 0; i < l; i++)\n\t\tif(numbers[i] != o.numbers[offset+i])\n\t\t\treturn false;\n\treturn true;\n}\n\nbool NumbersOutput::match(const string& output){\n\tNumbersOutput temp(output);\n\treturn operator==(temp);\n}\n\nOutputChecker* NumbersOutput::clone(){\n\treturn new NumbersOutput(outputExpected());\n}\n\nbool NumbersOutput::typeMatch(const string& text){\n\tint l=text.size();\n\tstring str;\n\tNumber number;\n\tfor(int i=0; i<l; i++){\n\t\tchar c=text[i];\n\t\t\/\/ Skip spaces\/CR\/LF... and *\n\t\tif(!isspace(c) && c!='*') {\n\t\t\tstr += c;\n\t\t}else if(str.size()>0) {\n\t\t\tif (!isNumStart(str[0])||\n\t\t\t\t!number.set(str)) return false;\n\t\t\tstr=\"\";\n\t\t}\n\t}\n\tif(str.size()>0){\n\t\tif(!isNumStart(str[0])||!number.set(str)) return false;\n\t}\n\treturn true;\n}\n\nstring NumbersOutput::type(){\n\treturn \"numbers\";\n}\n\nNumbersOutput::operator string () const{\n\tstring ret=\"[\";\n\tint l=numbers.size();\n\tfor(int i=0; i<l; i++){\n\t\tret += i > 0 ? \", \" : \"\";\n\t\tret += numbers[i];\n\t}\n\tret += \"]\";\n\treturn ret;\n}\n\n\/**\n * Class TextOutput Definitions\n *\/\n\nbool TextOutput::isAlpha(char c){\n\tif ( isalnum(c) ) return true;\n\treturn c < 0;\n}\n\nTextOutput::TextOutput(const string &text):OutputChecker(text){\n\tsize_t l = text.size();\n\tstring token;\n\tfor(size_t i = 0; i < l; i++){\n\t\tchar c = text[i];\n\t\tif( isAlpha(c) ){\n\t\t\ttoken += c;\n\t\t}else if(token.size() > 0){\n\t\t\ttokens.push_back(Tools::toLower(token));\n\t\t\ttoken=\"\";\n\t\t}\n\t}\n\tif(token.size()>0){\n\t\ttokens.push_back(Tools::toLower(token));\n\t}\n}\n\nbool TextOutput::operator==(const TextOutput& o) {\n\tsize_t l = tokens.size();\n\tif (o.tokens.size() < l) return false;\n\tint offset = o.tokens.size() - l;\n\tfor (size_t i = 0; i < l; i++)\n\t\tif (tokens[i] != o.tokens[ offset + i ])\n\t\t\treturn false;\n\treturn true;\n}\n\nbool TextOutput::match(const string& output) {\n\tTextOutput temp(output);\n\treturn operator== (temp);\n}\n\nOutputChecker* TextOutput::clone() {\n\treturn new TextOutput(outputExpected());\n}\n\nbool TextOutput::typeMatch(const string& text) {\n\treturn true;\n}\n\nstring TextOutput::type(){\n\treturn \"text\";\n}\n\n\/**\n * Class ExactTextOutput Definitions\n *\/\n\nbool ExactTextOutput::isAlpha(char c){\n\tif(isalnum(c)) return true;\n\treturn c < 0;\n}\n\nExactTextOutput::ExactTextOutput(const string &text):OutputChecker(text){\n\tstring clean = Tools::trim(text);\n\tif(clean.size() > 2 && clean[0] == '*') {\n\t\tstartWithAsterix = true;\n\t\tcleanText = clean.substr(2, clean.size() - 3);\n\t}else{\n\t\tstartWithAsterix =false;\n\t\tcleanText=clean.substr(1,clean.size()-2);\n\t}\n}\n\nstring ExactTextOutput::studentOutputExpected(){\n\treturn cleanText;\n}\n\nbool ExactTextOutput::operator==(const ExactTextOutput& o){\n\treturn match(o.text);\n}\n\nbool ExactTextOutput::match(const string& output){\n\tif (cleanText == output) return true;\n\tstring cleanOutput = output;\n\t\/\/ Removes last output char if is a newline and the last searched char is not a newline.\n\tif (cleanText.size() > 0 && cleanText[cleanText.size()-1] != '\\n' ) {\n\t\tif (cleanOutput.size() > 0 && cleanOutput[cleanOutput.size()-1] == '\\n' ) {\n\t\t\tcleanOutput = cleanOutput.substr(0, cleanOutput.size()-1);\n\t\t}\n\t}\n\tif (startWithAsterix && cleanText.size() < cleanOutput.size()) {\n\t\tsize_t start = cleanOutput.size() - cleanText.size();\n\t\treturn cleanText == cleanOutput.substr(start, cleanText.size());\n\t} else {\n\t\treturn cleanText == cleanOutput;\n\t}\n}\n\nOutputChecker* ExactTextOutput::clone(){\n\treturn new ExactTextOutput(outputExpected());\n}\n\nbool ExactTextOutput::typeMatch(const string& text){\n\tstring clean=Tools::trim(text);\n\treturn (clean.size()>1 && clean[0]=='\"' && clean[clean.size()-1]=='\"')\n\t\t\t||(clean.size()>3 && clean[0]=='*' && clean[1]=='\"' && clean[clean.size()-1]=='\"');\n}\n\nstring ExactTextOutput::type(){\n\treturn \"exact text\";\n}\n\n\/**\n * Class RegularExpressionOutput Definitions\n *\/\n\nRegularExpressionOutput::RegularExpressionOutput(const string &text, const string &actualCaseDescription):OutputChecker(text) {\n\n\terrorCase = actualCaseDescription;\n\tsize_t pos = 1;\n\tflagI = false;\n\tflagM = false;\n\tstring clean = Tools::trim(text);\n\tpos = clean.size() - 1;\n\twhile (clean[pos] != '\/' && pos > 0) {\n\t\tpos--;\n\t}\n\tcleanText = clean.substr(1,pos-1);\n\tif (pos + 1 != clean.size()) {\n\t\tpos = pos + 1;\n\t\t\/\/ Flags processing\n\t\twhile (pos < clean.size()) {\n\n\t\t\tswitch (clean[pos]) {\n\t\t\t\tcase 'i':\n\t\t\t\t\tflagI=true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\n\t\t\t\t\tflagM=true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ' ':\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tEvaluation* p_ErrorTest = Evaluation::getSinglenton();\n\t\t\t\t\tchar wrongFlag = clean[pos];\n\t\t\t\t\tstring flagCatch;\n\t\t\t\t\tstringstream ss;\n\t\t\t\t\tss << wrongFlag;\n\t\t\t\t\tss >> flagCatch;\n\t\t\t\t\tstring errorType = string(\"Error: invalid flag in regex output \")+ string(errorCase)+ string (\", found a \") + string(flagCatch) + string (\" used as a flag, only i and m available.\");\n\t\t\t\t\tconst char* flagError = errorType.c_str();\n\t\t\t\t\tp_ErrorTest->addFatalError(flagError);\n\t\t\t\t\tp_ErrorTest->outputEvaluation();\n\t\t\t\t\tabort();\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n}\n\n\/\/ Regular Expression compilation (with flags in mind) and comparison with the input and output evaluation\nbool RegularExpressionOutput::match (const string& output) {\n\n\treti=-1;\n\tconst char * in = cleanText.c_str();\n\t\/\/ Use POSIX-C regrex.h\n\t\/\/ Flag compilation\n\tif (flagI || flagM) {\n\t\tif (flagM && flagI) {\n\t\t\treti = regcomp(&expression, in, REG_EXTENDED | REG_NEWLINE | REG_ICASE);\n\t\t} else if (flagM) {\n\t\t\treti = regcomp(&expression, in, REG_EXTENDED | REG_NEWLINE);\n\t\t} else {\n\t\t\treti = regcomp(&expression, in, REG_EXTENDED | REG_ICASE);\n\t\t}\n\n\t\/\/ No flag compilation\n\t} else {\n\t\treti = regcomp(&expression, in, REG_EXTENDED);\n\t}\n\n\tif (reti == 0) { \/\/ Compilation was successful\n\n\t\tconst char * out = output.c_str();\n\t\treti = regexec(&expression, out, 0, NULL, 0);\n\n\t\tif (reti == 0) { \/\/ Match\n\t\t\treturn true;\n\t\t} else if (reti == REG_NOMATCH){ \/\/ No match\n\t\t\treturn false;\n\n\t\t} else { \/\/ Memory Error\n\t\t\tEvaluation* p_ErrorTest = Evaluation::getSinglenton();\n\t\t\tstring errorType = string(\"Error: out of memory error, during matching case \") + string(errorCase);\n\t\t\tconst char* flagError = errorType.c_str();\n\t\t\tp_ErrorTest->addFatalError(flagError);\n\t\t\tp_ErrorTest->outputEvaluation();\n\t\t\tabort();\n\t\t}\n\n\t} else { \/\/ Compilation error\n\t\tsize_t length = regerror(reti, &expression, NULL, 0);\n        char* bff = new char[length + 1];\n        (void) regerror(reti, &expression, bff, length);\n\t\tEvaluation* p_ErrorTest = Evaluation::getSinglenton();\n\t\tstring errorType = string(\"Error: regular expression compilation error\")+string (\" in case: \")+ string(errorCase) +string (\".\\n\")+ string(bff);\n\t\tconst char* flagError = errorType.c_str();\n\t\tp_ErrorTest->addFatalError(flagError);\n\t\tp_ErrorTest->outputEvaluation();\n\t\tabort();\n\t\treturn false;\n\t}\n}\n\n\/\/ Returns the expression without flags nor '\/'\nstring RegularExpressionOutput::studentOutputExpected() {return cleanText;}\n\nOutputChecker* RegularExpressionOutput::clone() {\n\treturn new RegularExpressionOutput(outputExpected(), errorCase);\n}\n\n\/\/ Tests if it's a regular expression. A regular expressions should be between \/..\/\nbool RegularExpressionOutput::typeMatch(const string& text) {\n\tstring clean=Tools::trim(text);\n\tif (clean.size() > 2 && clean[0] == '\/') {\n\t\tfor (size_t i = 1; i < clean.size(); i++) {\n\t\t\tif (clean[i] == '\/') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstring RegularExpressionOutput::type() {\n\treturn \"regular expression\";\n}\n\/**\n * Class Case Definitions\n * Case represents cases\n *\/\nCase::Case() {\n\treset();\n}\n\nvoid Case::reset() {\n\tinput = \"\";\n\toutput.clear();\n\tcaseDescription = \"\";\n\tgradeReduction = std::numeric_limits<float>::min();\n\tfailMessage = \"\";\n\tprogramToRun = \"\";\n\tprogramArgs = \"\";\n\tvariation = \"\";\n\texpectedExitCode = std::numeric_limits<int>::min();\n}\n\nvoid Case::addInput(string s) {\n\tinput += s;\n}\n\nstring Case::getInput() {\n\treturn input;\n}\n\nvoid Case::addOutput(string o) {\n\toutput.push_back(o);\n}\n\nconst vector< string > & Case::getOutput() {\n\treturn output;\n}\n\nvoid Case::setFailMessage(const string &s) {\n\tfailMessage = s;\n}\n\nstring Case::getFailMessage() {\n\treturn failMessage;\n}\nvoid Case::setCaseDescription(const string &s) {\n\tcaseDescription = s;\n}\n\nstring Case::getCaseDescription() {\n\treturn caseDescription;\n}\nvoid Case::setGradeReduction(float g) {\n\tgradeReduction = g;\n}\n\nfloat Case::getGradeReduction() {\n\treturn gradeReduction;\n}\n\nvoid Case::setExpectedExitCode(int e) {\n\texpectedExitCode = e;\n}\n\nint Case::getExpectedExitCode() {\n\treturn expectedExitCode;\n}\nvoid Case::setProgramToRun(const string &s) {\n\tprogramToRun = s;\n}\n\nstring Case::getProgramToRun() {\n\treturn programToRun;\n}\n\nvoid Case::setProgramArgs(const string &s) {\n\tprogramArgs = s;\n}\n\nstring Case::getProgramArgs() {\n\treturn programArgs;\n}\n\nvoid Case::setVariation(const string &s) {\n\tvariation = Tools::toLower(Tools::trim(s));\n}\n\nstring Case::getVariation() {\n\treturn variation;\n}\n\n\/**\n * Class TestCase Definitions\n * TestCase represents cases of test\n *\/\n\nvoid TestCase::cutOutputTooLarge(string &output) {\n\tif (output.size() > MAXOUTPUT) {\n\t\toutputTooLarge = true;\n\t\toutput.erase(0, output.size() - MAXOUTPUT);\n\t}\n}\n\nvoid TestCase::readWrite(int fdread, int fdwrite) {\n\tconst int MAX = 1024* 10 ;\n\t\/\/ Buffer size to read\n\tconst int POLLREAD = POLLIN | POLLPRI;\n\t\/\/ Poll to read from program\n\tstruct pollfd devices[2];\n\tdevices[0].fd = fdread;\n\tdevices[1].fd = fdwrite;\n\tchar buf[MAX];\n\tdevices[0].events = POLLREAD;\n\tdevices[1].events = POLLOUT;\n\tint res = poll(devices, programInput.size()>0?2:1, 0);\n\tif (res == -1) \/\/ Error\n\t\treturn;\n\tif (res == 0) \/\/ Nothing to do\n\t\treturn;\n\tif (devices[0].revents & POLLREAD) { \/\/ Read program output\n\t\tint readed = read(fdread, buf, MAX);\n\t\tif (readed > 0) {\n\t\t\tsizeReaded += readed;\n\t\t\tif (programInput.size() > 1) {\n\t\t\t\tprogramOutputBefore += string(buf, readed);\n\t\t\t\tcutOutputTooLarge(programOutputBefore);\n\t\t\t} else {\n\t\t\t\tprogramOutputAfter += string(buf, readed);\n\t\t\t\tcutOutputTooLarge(programOutputAfter);\n\t\t\t}\n\t\t}\n\t}\n\tif (programInput.size() > 0 && devices[1].revents & POLLOUT) { \/\/ Write to program\n\t\tint written = write(fdwrite, programInput.c_str(), Tools::nextLine(\n\t\t\t\tprogramInput));\n\t\tif (written > 0) {\n\t\t\tprogramInput.erase(0, written);\n\t\t}\n\t\tif(programInput.size()==0){\n\t\t\tclose(fdwrite);\n\t\t}\n\t}\n}\n\nvoid TestCase::addOutput(const string &o, const string &actualCaseDescription){\n\/\/ actualCaseDescripction, used to get current test name for Output recognition\n\tif(ExactTextOutput::typeMatch(o))\n\t\tthis->output.push_back(new ExactTextOutput(o));\n\telse if (RegularExpressionOutput::typeMatch(o))\n\t\tthis->output.push_back(new RegularExpressionOutput(o, actualCaseDescription));\n\telse if(NumbersOutput::typeMatch(o))\n\t\tthis->output.push_back(new NumbersOutput(o));\n\telse\n\t\tthis->output.push_back(new TextOutput(o));\n}\n\nvoid TestCase::setEnvironment(const char **environment) {\n\tenvv = environment;\n}\n\nvoid TestCase::setDefaultCommand() {\n\tcommand = \".\/vpl_test\";\n\targv = new const char*[2];\n\targv[0] = command;\n\targv[1] = NULL;\n}\n\nTestCase::TestCase(const TestCase &o) {\n\tid=o.id;\n\tcorrectOutput=o.correctOutput;\n\tcorrectExitCode = o.correctExitCode;\n\toutputTooLarge=o.outputTooLarge;\n\tprogramTimeout=o.programTimeout;\n\texecutionError=o.executionError;\n\tstrcpy(executionErrorReason,o.executionErrorReason);\n\tsizeReaded=o.sizeReaded;\n\tinput=o.input;\n\tcaseDescription=o.caseDescription;\n\tgradeReduction=o.gradeReduction;\n\texpectedExitCode = o.expectedExitCode;\n\texitCode = o.exitCode;\n\tfailMessage=o.failMessage;\n\tprogramToRun=o.programToRun;\n\tprogramArgs=o.programArgs;\n\tgradeReductionApplied=o.gradeReductionApplied;\n\tprogramOutputBefore=o.programOutputBefore;\n\tprogramOutputAfter=o.programOutputAfter;\n\tprogramInput=o.programInput;\n\tfor(size_t i = 0; i < o.output.size(); i++){\n\t\toutput.push_back(o.output[i]->clone());\n\t}\n\tsetDefaultCommand();\n}\n\nTestCase& TestCase::operator=(const TestCase &o) {\n\tid=o.id;\n\tcorrectOutput=o.correctOutput;\n\tcorrectExitCode = o.correctExitCode;\n\toutputTooLarge=o.outputTooLarge;\n\tprogramTimeout=o.programTimeout;\n\texecutionError=o.executionError;\n\tstrcpy(executionErrorReason,o.executionErrorReason);\n\tsizeReaded=o.sizeReaded;\n\tinput=o.input;\n\tcaseDescription=o.caseDescription;\n\tgradeReduction=o.gradeReduction;\n\tfailMessage=o.failMessage;\n\tprogramToRun=o.programToRun;\n\tprogramArgs=o.programArgs;\n\texpectedExitCode = o.expectedExitCode;\n\texitCode = o.exitCode;\n\tgradeReductionApplied=o.gradeReductionApplied;\n\tprogramOutputBefore=o.programOutputBefore;\n\tprogramOutputAfter=o.programOutputAfter;\n\tprogramInput=o.programInput;\n\tfor(size_t i=0; i<output.size(); i++)\n\t\tdelete output[i];\n\toutput.clear();\n\tfor(size_t i=0; i<o.output.size(); i++){\n\t\toutput.push_back(o.output[i]->clone());\n\t}\n\treturn *this;\n}\n\nTestCase::~TestCase() {\n\tfor(size_t i = 0; i < output.size(); i++)\n\t\tdelete output[i];\n}\n\nTestCase::TestCase(int id, const string &input, const vector<string> &output,\n\t\tconst string &caseDescription, const float gradeReduction,\n\t\tstring failMessage, string programToRun, string programArgs, int expectedExitCode) {\n\tthis->id = id;\n\tthis->input = input;\n\tfor(size_t i = 0; i < output.size(); i++){\n\t\taddOutput(output[i], caseDescription);\n\t}\n\tthis->caseDescription = caseDescription;\n\tthis->gradeReduction = gradeReduction;\n\tthis->expectedExitCode = expectedExitCode;\n\tthis->programToRun = programToRun;\n\tthis->programArgs = programArgs;\n\tthis->failMessage = failMessage;\n\texitCode = std::numeric_limits<int>::min();\n\toutputTooLarge = false;\n\tprogramTimeout = false;\n\texecutionError = false;\n\tcorrectOutput = false;\n\tcorrectExitCode = false;\n\tsizeReaded = 0;\n\tgradeReductionApplied =0;\n\tstrcpy(executionErrorReason, \"\");\n\tsetDefaultCommand();\n}\n\nbool TestCase::isCorrectResult() {\n\tbool correct = correctOutput &&\n\t\t\t      ! programTimeout &&\n\t\t\t\t  ! outputTooLarge &&\n\t\t\t\t  ! executionError;\n\treturn correct || (isExitCodeTested() && correctExitCode);\n}\n\nbool TestCase::isExitCodeTested() {\n\treturn expectedExitCode != std::numeric_limits<int>::min();\n}\n\nfloat TestCase::getGradeReduction() {\n\treturn gradeReduction;\n}\n\nvoid TestCase::setGradeReductionApplied(float r) {\n\tgradeReductionApplied=r;\n}\n\nfloat TestCase::getGradeReductionApplied() {\n\treturn gradeReductionApplied;\n}\n\nstring TestCase::getCaseDescription(){\n\treturn caseDescription;\n}\n\nstring TestCase::getCommentTitle(bool withGradeReduction=false) {\n\tchar buf[100];\n\tstring ret;\n\tsprintf(buf, \"Test %d\", id);\n\tret = buf;\n\tif (caseDescription.size() > 0) {\n\t\tret += \": \" + caseDescription;\n\t}\n\tif(withGradeReduction && getGradeReductionApplied()>0){\n\t\tsprintf(buf,\" (%.3f)\", -getGradeReductionApplied());\n\t\tret += buf;\n\t}\n\tret += '\\n';\n\treturn ret;\n}\n\nstring TestCase::getComment() {\n\tif (isCorrectResult()) {\n\t\treturn \"\";\n\t}\n\tchar buf[100];\n\tstring ret;\n\tif(output.size()==0){\n\t\tret += \"Configuration error in the test case: the output is not defined\";\n\t}\n\tif (programTimeout) {\n\t\tret += \"Program timeout\\n\";\n\t}\n\tif (outputTooLarge) {\n\t\tsprintf(buf, \"Program output too large (%dKb)\\n\", sizeReaded \/ 1024);\n\t\tret += buf;\n\t}\n\tif (executionError) {\n\t\tret += executionErrorReason + string(\"\\n\");\n\t}\n\tif (isExitCodeTested() && ! correctExitCode) {\n\t\tchar buf[250];\n\t\tsprintf(buf, \"Incorrect exit code. Expected %d, found %d\\n\", expectedExitCode, exitCode);\n\t\tret += buf;\n\t}\n\tif (! correctOutput) {\n\t\tif (failMessage.size()) {\n\t\t\tret += failMessage + \"\\n\";\n\t\t} else {\n\t\t\tret += \"Incorrect program output\\n\";\n\t\t\tret += \" --- Input ---\\n\";\n\t\t\tret += Tools::caseFormat(input);\n\t\t\tret += \"\\n --- Program output ---\\n\";\n\t\t\tret += Tools::caseFormat(programOutputBefore + programOutputAfter);\n\t\t\tif(output.size()>0){\n\t\t\t\tret += \"\\n --- Expected output (\"+output[0]->type()+\")---\\n\";\n\t\t\t\tret += Tools::caseFormat(output[0]->studentOutputExpected());\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid TestCase::splitArgs(string programArgs) {\n\tint l = programArgs.size();\n\tint nargs = 1;\n\tchar *buf = new char[programArgs.size() + 1];\n\tstrcpy(buf, programArgs.c_str());\n\targv = (const char **) new char*[programArgs.size() + 1];\n\targv[0] = command;\n\tbool inArg = false;\n\tchar separator = ' ';\n\tfor(int i=0; i < l; i++) { \/\/ TODO improve\n\t\tif ( ! inArg ) {\n\t\t\tif ( buf[i] == ' ' ) {\n\t\t\t\tbuf[i] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t} else if ( buf[i] == '\\'' ) {\n\t\t\t\targv[nargs++] = buf + i + 1;\n\t\t\t\tseparator = '\\'';\n\t\t\t} else if ( buf[i] == '\"' ) {\n\t\t\t\targv[nargs++] = buf + i + 1;\n\t\t\t\tseparator = '\"';\n\t\t\t} else if ( buf[i] != '\\0') {\n\t\t\t\targv[nargs++] = buf + i;\n\t\t\t\tseparator = ' ';\n\t\t\t}\n\t\t\tinArg = true;\n\t\t} else {\n\t\t\tif ( buf[i] == separator  ) {\n\t\t\t\tbuf[i] = '\\0';\n\t\t\t\tseparator = ' ';\n\t\t\t\tinArg = false;\n\t\t\t}\n\t\t}\n\t}\n\targv[nargs] = NULL;\n}\n\nvoid TestCase::runTest(time_t timeout) {\/\/ Timeout in seconds\n\ttime_t start = time(NULL);\n\tint pp1[2]; \/\/ Send data\n\tint pp2[2]; \/\/ Receive data\n\tif (pipe(pp1) == -1 || pipe(pp2) == -1) {\n\t\texecutionError = true;\n\t\tsprintf(executionErrorReason, \"Internal error: pipe error (%s)\",\n\t\t\t\tstrerror(errno));\n\t\treturn;\n\t}\n\tif ( programToRun > \"\" && programToRun.size() < 512) {\n\t\tcommand = programToRun.c_str();\n\t}\n\tif ( ! Tools::existFile(command) ){\n\t\texecutionError = true;\n\t\tsprintf(executionErrorReason, \"Execution file not found '%s'\", command);\n\t\treturn;\n\t}\n\tpid_t pid;\n\tif ( programArgs.size() > 0) {\n\t\tsplitArgs(programArgs);\n\t}\n\tif ((pid = fork()) == 0) {\n\t\t\/\/ Execute\n\t\tclose(pp1[1]);\n\t\tdup2(pp1[0], STDIN_FILENO);\n\t\tclose(pp2[0]);\n\t\tdup2(pp2[1], STDOUT_FILENO);\n\t\tdup2(STDOUT_FILENO, STDERR_FILENO);\n\t\tsetpgrp();\n\t\texecve(command, (char * const *) argv, (char * const *) envv);\n\t\tperror(\"Internal error, execve fails\");\n\t\tabort(); \/\/end of child\n\t}\n\tif (pid == -1) {\n\t\texecutionError = true;\n\t\tsprintf(executionErrorReason, \"Internal error: fork error (%s)\",\n\t\t\t\tstrerror(errno));\n\t\treturn;\n\t}\n\tclose(pp1[0]);\n\tclose(pp2[1]);\n\tint fdwrite = pp1[1];\n\tint fdread = pp2[0];\n\tTools::fdblock(fdwrite, false);\n\tTools::fdblock(fdread, false);\n\tprogramInput = input;\n\tif(programInput.size()==0){ \/\/ No input\n\t\tclose(fdwrite);\n\t}\n\tprogramOutputBefore = \"\";\n\tprogramOutputAfter = \"\";\n\tpid_t pidr;\n\tint status;\n\texitCode = std::numeric_limits<int>::min();\n\twhile ((pidr = waitpid(pid, &status, WNOHANG | WUNTRACED)) == 0) {\n\t\treadWrite(fdread, fdwrite);\n\t\tusleep(5000);\n\t\t\/\/ TERMSIG or timeout or program output too large?\n\t\tif (Stop::isTERMRequested() || (time(NULL) - start) >= timeout\n\t\t\t\t|| outputTooLarge) {\n\t\t\tif ((time(NULL) - start) >= timeout) {\n\t\t\t\tprogramTimeout = true;\n\t\t\t}\n\t\t\tkill(pid, SIGTERM); \/\/ Send SIGTERM normal termination\n\t\t\tint otherstatus;\n\t\t\tusleep(5000);\n\t\t\tif (waitpid(pid, &otherstatus, WNOHANG | WUNTRACED) == pid) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (kill(pid, SIGQUIT) == 0) { \/\/ Kill\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (pidr == pid) {\n\t\tif (WIFSIGNALED(status)) {\n\t\t\tint signal = WTERMSIG(status);\n\t\t\texecutionError = true;\n\t\t\tsprintf(executionErrorReason,\n\t\t\t\t\t\"Program terminated due to \\\"%s\\\" (%d)\\n\", strsignal(\n\t\t\t\t\t\t\tsignal), signal);\n\t\t}\n\t\tif (WIFEXITED(status)) {\n\t\t\texitCode = WEXITSTATUS(status);\n\t\t} else {\n\t\t\texecutionError = true;\n\t\t\tstrcpy(executionErrorReason,\n\t\t\t\t\t\"Program terminated but unknown reason.\");\n\t\t}\n\t} else if (pidr != 0) {\n\t\texecutionError = true;\n\t\tstrcpy(executionErrorReason, \"waitpid error\");\n\t}\n\treadWrite(fdread, fdwrite);\n\tcorrectExitCode = isExitCodeTested() && expectedExitCode == exitCode;\n\tcorrectOutput = match(programOutputAfter)\n\t\t\t     || match(programOutputBefore + programOutputAfter);\n}\n\nbool TestCase::match(string data) {\n\tfor (size_t i = 0; i < output.size(); i++)\n\t\tif (output[i]->match(data))\n\t\t\treturn true;\n\treturn false;\n}\n\n\/**\n * Class Evaluation Definitions\n *\/\n\nEvaluation::Evaluation() {\n\tgrade = 0;\n\tncomments = 0;\n\tnerrors = 0;\n\tnruns = 0;\n\tnoGrade = true;\n}\n\nEvaluation* Evaluation::getSinglenton() {\n\tif (singlenton == NULL) {\n\t\tsinglenton = new Evaluation();\n\t}\n\treturn singlenton; \/\/ Fixes by Jan Derriks\n}\n\nvoid Evaluation::deleteSinglenton(){\n\tif (singlenton != NULL) {\n\t\tdelete singlenton;\n\t\tsinglenton = NULL;\n\t}\n}\n\nvoid Evaluation::addTestCase(Case &caso) {\n\tif ( caso.getVariation().size() && caso.getVariation() != variation ) {\n\t\treturn;\n\t}\n\ttestCases.push_back(TestCase(testCases.size() + 1, caso.getInput(), caso.getOutput(),\n\t\t\tcaso.getCaseDescription(), caso.getGradeReduction(), caso.getFailMessage(),\n\t\t\tcaso.getProgramToRun(), caso.getProgramArgs(), caso.getExpectedExitCode() ));\n}\n\nvoid Evaluation::removeLastNL(string &s) {\n\tif (s.size() > 0 && s[s.size() - 1] == '\\n') {\n\t\ts.resize(s.size() - 1);\n\t}\n}\n\nbool Evaluation::cutToEndTag(string &value, const string &endTag) {\n\tsize_t pos;\n\tif (endTag.size() && (pos = value.find(endTag)) != string::npos) {\n\t\tvalue.resize(pos);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid Evaluation::loadTestCases(string fname) {\n\tif(!Tools::existFile(fname)) return;\n\tconst char *CASE_TAG = \"case=\";\n\tconst char *INPUT_TAG = \"input=\";\n\tconst char *INPUT_END_TAG = \"inputend=\";\n\tconst char *OUTPUT_TAG = \"output=\";\n\tconst char *OUTPUT_END_TAG = \"outputend=\";\n\tconst char *GRADEREDUCTION_TAG = \"gradereduction=\";\n\tconst char *FAILMESSAGE_TAG = \"failmessage=\";\n\tconst char *PROGRAMTORUN_TAG = \"programtorun=\";\n\tconst char *PROGRAMARGS_TAG = \"programarguments=\";\n\tconst char *EXPECTEDEXITCODE_TAG = \"expectedexitcode=\";\n\tconst char *VARIATION_TAG = \"variation=\";\n\tenum {\n\t\tregular, ininput, inoutput\n\t} state;\n\tbool inCase = false;\n\tvector<string> lines = Tools::splitLines(Tools::readFile(fname));\n    remove(fname.c_str());\n\tstring inputEnd = \"\";\n\tstring outputEnd = \"\";\n\tCase caso;\n\tstring output = \"\";\n\tstring tag, value;\n\t\/* must be changed from String\n\t * to pair type (regexp o no) and string. *\/\n\tstate = regular;\n\tint nlines = lines.size();\n\tfor (int i = 0; i < nlines; i++) {\n\t\tstring &line = lines[i];\n\t\tTools::parseLine(line, tag, value);\n\t\tif (state == ininput) {\n\t\t\tif (inputEnd.size()) { \/\/ Check for end of input.\n\t\t\t\tsize_t pos = line.find(inputEnd);\n\t\t\t\tif (pos == string::npos) {\n\t\t\t\t\tcaso.addInput(line + \"\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tcutToEndTag(line, inputEnd);\n\t\t\t\t\tcaso.addInput(line);\n\t\t\t\t\tstate = regular;\n\t\t\t\t\tcontinue; \/\/ Next line.\n\t\t\t\t}\n\t\t\t} else if (tag.size() && (tag == OUTPUT_TAG || tag\n\t\t\t\t\t== GRADEREDUCTION_TAG || tag == CASE_TAG)) {\/\/ New valid tag.\n\t\t\t\tstate = regular;\n\t\t\t\t\/\/ Go on to process the current tag.\n\t\t\t} else {\n\t\t\t\tcaso.addInput(line + \"\\n\");\n\t\t\t\tcontinue; \/\/ Next line.\n\t\t\t}\n\t\t} else if (state == inoutput) {\n\t\t\tif (outputEnd.size()) { \/\/ Check for end of output.\n\t\t\t\tsize_t pos = line.find(outputEnd);\n\t\t\t\tif (pos == string::npos) {\n\t\t\t\t\toutput += line + \"\\n\";\n\t\t\t\t} else {\n\t\t\t\t\tcutToEndTag(line, outputEnd);\n\t\t\t\t\toutput += line;\n\t\t\t\t\tcaso.addOutput(output);\n\t\t\t\t\toutput = \"\";\n\t\t\t\t\tstate = regular;\n\t\t\t\t\tcontinue; \/\/ Next line.\n\t\t\t\t}\n\t\t\t} else if (tag.size() && (tag == INPUT_TAG || tag == OUTPUT_TAG\n\t\t\t\t\t|| tag == GRADEREDUCTION_TAG || tag == CASE_TAG)) {\/\/ New valid tag.\n\t\t\t\tremoveLastNL(output);\n\t\t\t\tcaso.addOutput(output);\n\t\t\t\toutput = \"\";\n\t\t\t\tstate = regular;\n\t\t\t} else {\n\t\t\t\toutput += line + \"\\n\";\n\t\t\t\tcontinue; \/\/ Next line.\n\t\t\t}\n\t\t}\n\t\tif (state == regular && tag.size()) {\n\t\t\tif (tag == INPUT_TAG) {\n\t\t\t\tinCase = true;\n\t\t\t\tif (cutToEndTag(value, inputEnd)) {\n\t\t\t\t\tcaso.addInput(value);\n\t\t\t\t} else {\n\t\t\t\t\tstate = ininput;\n\t\t\t\t\tcaso.addInput(value + '\\n');\n\t\t\t\t}\n\t\t\t} else if (tag == OUTPUT_TAG) {\n\t\t\t\tinCase = true;\n\t\t\t\tif (cutToEndTag(value, outputEnd))\n\t\t\t\t\tcaso.addOutput(value);\n\t\t\t\telse {\n\t\t\t\t\tstate = inoutput;\n\t\t\t\t\toutput = value + '\\n';\n\t\t\t\t}\n\t\t\t} else if (tag == GRADEREDUCTION_TAG) {\n\t\t\t\tinCase = true;\n\t\t\t\tvalue = Tools::trim(value);\n\t\t\t\t\/\/ A percent value?\n\t\t\t\tif( value.size() > 1 && value[ value.size() - 1 ] == '%' ){\n\t\t\t\t\tfloat percent = atof(value.c_str());\n\t\t\t\t\tcaso.setGradeReduction((grademax-grademin)*percent\/100);\n\t\t\t\t}else{\n\t\t\t\t\tcaso.setGradeReduction( atof(value.c_str()) );\n\t\t\t\t}\n\t\t\t} else if (tag == EXPECTEDEXITCODE_TAG) {\n\t\t\t\tcaso.setExpectedExitCode( atoi(value.c_str()) );\n\t\t\t} else if (tag == PROGRAMTORUN_TAG) {\n\t\t\t\tcaso.setProgramToRun(Tools::trim(value));\n\t\t\t} else if (tag == PROGRAMARGS_TAG) {\n\t\t\t\tcaso.setProgramArgs(Tools::trim(value));\n\t\t\t} else if (tag == FAILMESSAGE_TAG) {\n\t\t\t\tcaso.setFailMessage(Tools::trim(value));\n\t\t\t} else if (tag == VARIATION_TAG) {\n\t\t\t\tcaso.setVariation(value);\n\t\t\t} else if (tag == INPUT_END_TAG) {\n\t\t\t\tinputEnd = Tools::trim(value);\n\t\t\t} else if (tag == OUTPUT_END_TAG) {\n\t\t\t\toutputEnd = Tools::trim(value);\n\t\t\t} else if (tag == CASE_TAG) {\n\t\t\t\tif (inCase) {\n\t\t\t\t\taddTestCase(caso);\n\t\t\t\t\tcaso.reset();\n\t\t\t\t}\n\t\t\t\tinCase = true;\n\t\t\t\tcaso.setCaseDescription( Tools::trim(value) );\n\t\t\t} else {\n\t\t\t\tif ( line.size() > 0 ) {\n\t\t\t\t\tchar buf[250];\n\t\t\t\t\tsprintf(buf,\"Syntax error: unexpected line %d \", i+1);\n\t\t\t\t\taddFatalError(buf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\/\/ TODO review\n\tif (state == inoutput) {\n\t\tremoveLastNL(output);\n\t\tcaso.addOutput(output);\n\t}\n\tif (inCase) { \/\/ Last case => save current.\n\t\taddTestCase(caso);\n\t}\n}\n\nbool Evaluation::loadParams() {\n\tgrademin= Tools::getenv(\"VPL_GRADEMIN\", 0.0);\n\tgrademax = Tools::getenv(\"VPL_GRADEMAX\", 10);\n\tmaxtime = (int) Tools::getenv(\"VPL_MAXTIME\", 20);\n\tvariation = Tools::toLower(Tools::trim(Tools::getenv(\"VPL_VARIATION\",\"\")));\n\tnoGrade = grademin >= grademax;\n\treturn true;\n}\n\nvoid Evaluation::addFatalError(const char *m) {\n\tfloat reduction = grademax - grademin;\n\tif (ncomments >= MAXCOMMENTS)\n\t\tncomments = MAXCOMMENTS - 1;\n\n\tsnprintf(titles[ncomments], MAXCOMMENTSTITLELENGTH, \"%s\", m);\n\tsnprintf(titlesGR[ncomments], MAXCOMMENTSTITLELENGTH, \"%s (%.2f)\", m, reduction);\n\tstrcpy(comments[ncomments], \"\");\n\tncomments ++;\n\tgrade = grademin;\n}\n\nvoid Evaluation::runTests() {\n\tif (testCases.size() == 0) {\n\t\treturn;\n\t}\n\tif (maxtime < 0) {\n\t\taddFatalError(\"Global timeout\");\n\t\treturn;\n\t}\n\tnerrors = 0;\n\tnruns = 0;\n\tgrade = grademax;\n\tfloat defaultGradeReduction = (grademax - grademin) \/ testCases.size();\n\tint timeout = maxtime \/ testCases.size();\n\tfor (size_t i = 0; i < testCases.size(); i++) {\n\t\tprintf(\"Testing %lu\/%lu : %s\\n\", (unsigned long) i+1, (unsigned long)testCases.size(), testCases[i].getCaseDescription().c_str());\n\t\tif (timeout <= 1 || Timer::elapsedTime() >= maxtime) {\n\t\t\tgrade = grademin;\n\t\t\taddFatalError(\"Global timeout\");\n\t\t\treturn;\n\t\t}\n\t\tif (maxtime - Timer::elapsedTime() < timeout) { \/\/ Try to run last case\n\t\t\ttimeout = maxtime - Timer::elapsedTime();\n\t\t}\n\t\ttestCases[i].runTest(timeout);\n\t\tnruns++;\n\t\tif (!testCases[i].isCorrectResult()) {\n\t\t\tif (Stop::isTERMRequested())\n\t\t\t\tbreak;\n\t\t\tfloat gr = testCases[i].getGradeReduction();\n\t\t\tif (gr == std::numeric_limits<float>::min())\n\t\t\t\ttestCases[i].setGradeReductionApplied(defaultGradeReduction);\n\t\t\telse\n\t\t\t\ttestCases[i].setGradeReductionApplied(gr);\n\t\t\tgrade -= testCases[i].getGradeReductionApplied();\n\t\t\tif (grade < grademin) {\n\t\t\t\tgrade = grademin;\n\t\t\t}\n\t\t\tnerrors++;\n\t\t\tif(ncomments<MAXCOMMENTS){\n\t\t\t\tstrncpy(titles[ncomments], testCases[i].getCommentTitle().c_str(),\n\t\t\t\t\t\tMAXCOMMENTSTITLELENGTH);\n\t\t\t\tstrncpy(titlesGR[ncomments], testCases[i].getCommentTitle(true).c_str(),\n\t\t\t\t\t\tMAXCOMMENTSTITLELENGTH);\n\t\t\t\tstrncpy(comments[ncomments], testCases[i].getComment().c_str(),\n\t\t\t\t\t\tMAXCOMMENTSLENGTH);\n\t\t\t\tncomments++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Evaluation::outputEvaluation() {\n\tconst char* stest[] = {\" test\", \"tests\"};\n\tif (testCases.size() == 0) {\n\t\tprintf(\"<|--\\n\");\n\t\tprintf(\"-No test case found\\n\");\n\t\tprintf(\"--|>\\n\");\n\t}\n\tif (ncomments > 1) {\n\t\tprintf(\"\\n<|--\\n\");\n\t\tprintf(\"-Failed tests\\n\");\n\t\tfor (int i = 0; i < ncomments; i++) {\n\t\t\tprintf(\"%s\", titles[i]);\n\t\t}\n\t\tprintf(\"--|>\\n\");\n\t}\n\tif ( ncomments > 0 ) {\n\t\tprintf(\"\\n<|--\\n\");\n\t\tfor (int i = 0; i < ncomments; i++) {\n\t\t\tprintf(\"-%s\", titlesGR[i]);\n\t\t\tprintf(\"%s\\n\", comments[i]);\n\t\t}\n\t\tprintf(\"--|>\\n\");\n\t}\n\tint passed = nruns - nerrors;\n\tif ( nruns > 0 ) {\n\t\tprintf(\"\\n<|--\\n\");\n\t\tprintf(\"-Summary of tests\\n\");\n\t\tprintf(\">+------------------------------+\\n\");\n\t\tprintf(\">| %2d %s run\/%2d %s passed |\\n\",\n\t\t\t\tnruns, nruns==1?stest[0]:stest[1],\n\t\t\t\tpassed, passed==1?stest[0]:stest[1]); \/\/ Taken from Dominique Thiebaut\n\t\tprintf(\">+------------------------------+\\n\");\n\t\tprintf(\"\\n--|>\\n\");\n\t}\n\tif ( ! noGrade ) {\n\t\tchar buf[100];\n\t\tsprintf(buf, \"%5.2f\", grade);\n\t\tint len = strlen(buf);\n\t\tif (len > 3 && strcmp(buf + (len - 3), \".00\") == 0)\n\t\t\tbuf[len - 3] = 0;\n\t\tprintf(\"\\nGrade :=>>%s\\n\", buf);\n\t}\n\tfflush(stdout);\n}\n\nvoid nullSignalCatcher(int n) {\n\t\/\/printf(\"Signal %d\\n\",n);\n}\n\nvoid signalCatcher(int n) {\n\t\/\/printf(\"Signal %d\\n\",n);\n\tif (Stop::isTERMRequested()) {\n\t\tEvaluation* obj = Evaluation::getSinglenton();\n\t\tobj->outputEvaluation();\n\t\tabort();\n\t}\n\tEvaluation *obj = Evaluation::getSinglenton();\n\tif (n == SIGTERM) {\n\t\tobj->addFatalError(\"Global test timeout (TERM signal received)\");\n\t} else {\n\t\tobj->addFatalError(\"Internal test error\");\n\t\tobj->outputEvaluation();\n\t\tStop::setTERMRequested();\n\t\tabort();\n\t}\n\talarm(1);\n}\n\nvoid setSignalsCatcher() {\n\t\/\/ Removes as many signal controllers as possible\n\tfor(int i=0;i<31; i++)\n\t\tsignal(i, nullSignalCatcher);\n\tsignal(SIGINT, signalCatcher);\n\tsignal(SIGQUIT, signalCatcher);\n\tsignal(SIGILL, signalCatcher);\n\tsignal(SIGTRAP, signalCatcher);\n\tsignal(SIGFPE, signalCatcher);\n\tsignal(SIGSEGV, signalCatcher);\n\tsignal(SIGALRM, signalCatcher);\n\tsignal(SIGTERM, signalCatcher);\n}\n\nint main(int argc, char *argv[], const char **env) {\n\tTimer::start();\n\tTestCase::setEnvironment(env);\n\tsetSignalsCatcher();\n\tEvaluation* obj = Evaluation::getSinglenton();\n\tobj->loadParams();\n\tobj->loadTestCases(\"evaluate.cases\");\n\tobj->runTests();\n\tobj->outputEvaluation();\n\treturn EXIT_SUCCESS;\n}\n","vpl_environment.sh":"#!\/bin\/bash\nexport VPL_LANG='en_US.UTF-8'\nexport MOODLE_USER_ID='3'\nexport MOODLE_USER_NAME='Juan Carlos Rodr\u00edguez del Pino'\nexport MOODLE_USER_EMAIL='jcrodriguez@dis.ulpgc.es'\nexport VPL_MAXTIME=960\nexport VPL_MAXMEMORY=1073741824\nexport VPL_MAXFILESIZE=67108864\nexport VPL_MAXPROCESSES=200\nexport VPL_COMPILATIONFAILED='The compilation or preparation of execution has failed'\nexport VPL_SUBFILE0='a.c'\nexport VPL_SUBFILE1='b.c'\nexport VPL_SUBFILES=\"a.c\nb.c\n\"\nexport VPL_VARIATION=''\n","common_script.sh":"#!\/bin\/bash\n# Default common funtions for scripts of VPL\n# Copyright (C) 2016 Juan Carlos Rodr\u00edguez-del-Pino\n# License http:\/\/www.gnu.org\/copyleft\/gpl.html GNU GPL v3 or later\n# Author Juan Carlos Rodr\u00edguez-del-Pino <jcrodriguez@dis.ulpgc.es>\n\n#load VPL environment vars\nif [ \"$PROFILE_RUNNED\" == \"\" ] ; then\n\texport PROFILE_RUNNED=yes\n\tif [ -f \/etc\/profile ] ; then\n\t\tcp \/etc\/profile .localvplprofile\n\t\tchmod +x .localvplprofile\n\t\t. .localvplprofile\n\t\trm .localvplprofile\n\tfi\nfi\n. vpl_environment.sh\n#Use current lang\nexport LC_ALL=$VPL_LANG 1>\/dev\/null 2>vpl_set_locale_error\n#If current lang not available use en_US.UTF-8\nif [ -s vpl_set_locale_error ] ; then\n\texport LC_ALL=en_US.UTF-8  1>\/dev\/null 2>\/dev\/null\nfi\nrm vpl_set_locale_error 1>\/dev\/null 2>\/dev\/null\n#functions\n\n# Wait until a program ($1 e.g. execution_int) of the current user ends. \nfunction wait_end {\n\tlocal PSRESFILE\n\tPSRESFILE=.vpl_temp_search_program\n\t#wait start until 5s\n\tfor I in 1 .. 5\n\tdo\n\t\tsleep 1s\n\t\tps -f -u $USER > $PSRESFILE\n\t\tgrep $1 $PSRESFILE &> \/dev\/null\n\t\tif [ \"$?\" == \"0\" ] ; then\n\t\t\tbreak\n\t\tfi\n\tdone\n\twhile :\n\tdo\n\t\tsleep 1s\n\t\tps -f -u $USER > $PSRESFILE\n\t\tgrep $1 $PSRESFILE &> \/dev\/null\n\t\tif [ \"$?\" != \"0\" ] ; then\n\t\t\trm $PSRESFILE\n\t\t\treturn\n\t\tfi\n\tdone\n}\n\n# Adds code to vpl_execution for getting the version of $PROGRAM\n# $1: version command line switch (e.g. -version)\n# $2: number of lines to show. Default 2\nfunction get_program_version {\n\tlocal nhl\n\tif [ \"$2\" == \"\" ] ; then\n\t\tnhl=2\n\telse\n\t\tnhl=$2\n\tfi\n\t\n\techo \"#!\/bin\/bash\" > vpl_execution\n\tif [ \"$1\" == \"unknown\" ] ; then\n\t\techo \"echo \\\"$PROGRAM version unknown\\\"\" >> vpl_execution\n\telse\n\t\techo \"$PROGRAM $1 | head -n $nhl\" >> vpl_execution\n\tfi\n\tchmod +x vpl_execution\n\texit\n}\n\n# Populate SOURCE_FILES, SOURCE_FILES_LINE and SOURCE_FILE0 with files\n# of extensions passed. E.g. get_source_files cpp C\nfunction get_source_files {\n\tlocal ext\n\tSOURCE_FILES=\"\"\n\tSOURCE_FILES_LINE=\"\"\n\tfor ext in \"$@\"\n\tdo\n\t\tif [ \"$ext\" == \"NOERROR\" ] ; then\n\t\t\tbreak\n\t\tfi\n\t    local source_files_ext=\"$(find . -name \"*.$ext\" -print | sed 's\/^.\\\/\/\/g' | sed 's\/ \/\\\\ \/g')\"\n\t    if [ \"$SOURCE_FILES_LINE\" == \"\" ] ; then\n\t        SOURCE_FILES_LINE=\"$source_files_ext\"\n\t    else\n\t        SOURCE_FILES_LINE=$(echo -en \"$SOURCE_FILES_LINE\\n$source_files_ext\")\n\t    fi\n\t    local source_files_ext_s=\"$(find . -name \"*.$ext\" -print | sed 's\/^.\\\/\/\/g')\"\n\t    if [ \"$SOURCE_FILES\" == \"\" ] ; then\n\t        SOURCE_FILES=\"$source_files_ext_s\"\n\t    else\n\t        SOURCE_FILES=$(echo -en \"$SOURCE_FILES\\n$source_files_ext_s\")\n\t    fi\n\tdone\n\n    if [ \"$SOURCE_FILES\" != \"\" -o \"$1\" == \"b64\" ] ; then\n\t\tlocal file_name\n\t\tlocal SIFS=$IFS\n\t\tIFS=$'\\n'\n\t\tfor file_name in $SOURCE_FILES\n\t\tdo\n\t\t\tSOURCE_FILE0=$file_name\n\t\t\tbreak\n\t\tdone\n\t\tIFS=$SIFS\n\t\treturn 0\n\tfi\n\tif [ \"$ext\" == \"NOERROR\" ] ; then\n\t\treturn 1\n\tfi\n\n\techo \"To run this type of program you need some file with extension \\\"$@\\\"\"\n\texit 0;\n}\n\n# Take SOURCE_FILES and write at $1 file\nfunction generate_file_of_files {\n\tif [ -f \"$1\" ] ; then\n\t\trm \"$1\"\n\tfi\n\ttouch $1 \n\tlocal file_name\n\tlocal SIFS=$IFS\n\tIFS=$'\\n'\n\tfor file_name in $SOURCE_FILES\n\tdo\n\t\tif [ \"$2\" == \"\" ] ; then\n\t\t\techo \"\\\"$file_name\\\"\" >> \"$1\"\n\t\telse\n\t\t\techo \"$file_name\" >> \"$1\"\n\t\tfi\n\tdone\n\tIFS=$SIFS\n}\n\n# Set FIRST_SOURCE_FILE to the first VPL_SUBFILE# with extension in parameters $@\nfunction get_first_source_file {\n\tlocal ext\n\tlocal FILENAME\n\tlocal FILEVAR\n\tlocal i\n\tfor i in {0..100000}\n\tdo\n\t\tFILEVAR=\"VPL_SUBFILE${i}\"\n\t\tFILENAME=\"${!FILEVAR}\"\n\t\tif [ \"\" == \"$FILENAME\" ] ; then\n\t\t\tbreak\n\t\tfi\n\t\tfor ext in \"$@\"\n\t\tdo\n\t\t    if [ \"${FILENAME##*.}\" == \"$ext\" ] ; then\n\t\t        FIRST_SOURCE_FILE=$FILENAME\n\t\t        return 0\n\t    \tfi\n\t\tdone\n\tdone\n\tif [ \"$ext\" == \"NOERROR\" ] ; then\n\t\treturn 1\n\tfi\n\techo \"To run this type of program you need some file with extension \\\"$@\\\"\"\n\texit 0;\n}\n\n# Check program existence ($@) and set $PROGRAM and PROGRAMPATH\nfunction check_program {\n\tPROGRAM=\n\tlocal check\n\tfor check in \"$@\"\n\tdo\n\t\tlocal PROPATH=$(command -v $check)\n\t\tif [ \"$PROPATH\" == \"\" ] ; then\n\t\t\tcontinue\n\t\tfi\n\t\tPROGRAM=$check\n\t\tPROGRAMPATH=$PROPATH\n\t\treturn 0\n\tdone\n\tif [ \"$check\" == \"NOERROR\" ] ; then\n\t\treturn 1\n\tfi\n\techo \"The execution server needs to install \\\"$1\\\" to run this type of program\"\n\texit 0;\n}\n\n# Compile \nfunction compile_typescript {\n\tcheck_program tsc NOERROR\n\tif [ \"$PROGRAM\" == \"\" ] ; then\n\t\treturn 0\n\tfi\n\tget_source_files ts NOERROR\n\tSAVEIFS=$IFS\n\tIFS=$'\\n'\n\tfor FILENAME in $SOURCE_FILES\n\tdo\n\t\ttsc \"$FILENAME\" | sed 's\/\\x1b\\[[0-9;]*[a-zA-Z]\/\/g'\n\tdone\n\tIFS=$SAVEIFS\n}\n\nfunction compile_scss {\n\tcheck_program sass NOERROR\n\tif [ \"$PROGRAM\" == \"\" ] ; then\n\t\treturn 0\n\tfi\n\tget_source_files scss NOERROR\n\tSAVEIFS=$IFS\n\tIFS=$'\\n'\n\tfor FILENAME in $SOURCE_FILES\n\tdo\n\t\tsass \"$FILENAME\"\n\tdone\n\tIFS=$SAVEIFS\n}\n\n\n#Decode BASE64 files\nget_source_files b64\nSAVEIFS=$IFS\nIFS=$'\\n'\nfor FILENAME in $SOURCE_FILES\ndo\n\tif [ -f \"$FILENAME\" ] ; then\n\t\tBINARY=$(echo \"$FILENAME\" | sed -r \"s\/\\.b64$\/\/\")\n\t\tif [ ! -f  \"$BINARY\" ] ; then\n\t\t\tbase64 -i -d \"$FILENAME\" > \"$BINARY\"\n\t\tfi\n\tfi\ndone\nSOURCE_FILES=\"\"\n#Security Check: pre_vpl_run.sh was submitted by a student?\nVPL_NS=true\nfor FILENAME in $VPL_SUBFILES\ndo\n\tif [ \"$FILENAME\" == \"pre_vpl_run.sh\" ] || [ \"$FILENAME\" == \"pre_vpl_run.sh.b64\" ] ; then\n\t\tVPL_NS=false\n\t\tbreak\n\tfi\ndone\nIFS=$SAVEIFS\nif $VPL_NS ; then\n\tif [ -x pre_vpl_run.sh ] ; then\n\t\t.\/pre_vpl_run.sh\n\tfi\nfi\n"},"filestodelete":{"vpl_run.sh":1,"vpl_debug.sh":1,"vpl_evaluate.sh":1,"vpl_evaluate.cases":1,"vpl_evaluate.cpp":1},"maxtime":960,"maxfilesize":67108864,"maxmemory":1073741824,"maxprocesses":200,"runscript":null,"debugscript":"c","userid":"3","activityid":"7","execute":"vpl_evaluate.sh","interactive":0,"lang":"en_US.UTF-8","fileencoding":{"vpl_run.sh":0,"vpl_debug.sh":0,"vpl_evaluate.sh":0,"vpl_evaluate.cases":0,"a.c":0,"b.c":0,"vpl_evaluate.cpp":0,"vpl_environment.sh":0,"common_script.sh":0},"pluginversion":2021061600},"id":"3-79890-902232400"} 